"""Code for CC/PBSA, a fast tool for estimating mutational free energy
differences.
"""
import os
import shutil
import subprocess
import numpy as np
import pandas as pd
import pymol
pymol.finish_launching(['pymol', '-qc'])
cmd = pymol.cmd

def int_in_str(lst):
    converted = ''.join([item for item in lst if item.isdigit()])
    return int(converted)

def log(fname, proc_obj):
    """Used to log some of GROMACS output
    """
    log_file = open(fname, 'a')
    log_file.write(proc_obj.stdout.decode('utf-8'))
    log_file.close()


def gmx(prog, **kwargs):
    """Uses the subprocess module to run a gmx (GROMACS) program. Returns the
    process object. **kwargs will be passed to subprocess.run
    """
    assert type(prog) == list, "Pass a list of arguments you would use after \
        \"gmx -quiet\"."
    gmx = subprocess.run(['gmx', '-quiet'] + prog, **kwargs)

    return gmx


def makedir(dirname):
    if not os.path.isdir(dirname):
        os.mkdir(dirname)

    else:
        print("Directory \"%s\" already exists. Ignoring this function call!" %
            dirname)
        pass


def unpack(lst=[]):
	"""Unpacks a nested list. Does not care about the deepness of nesting since
		it calls itself recursively.
	"""
	unpacked = []
	for i in lst:
		if type(i) is list:
			unpacked.extend(unpack(i))

		else:
			unpacked.append(i)

	return unpacked


class DataGenerator:
    """Main class containing the methods to generate the data for CC/PBSA.
    Creates a directory with the name of the wildtype (wt) protein and
    subdirectories for each structure ensemble (wt and mutant). If the concoord
    method was called, then each subdirectory will have another layer of
    subdirectories for the individual GROMACS runs.The user will have to pass
    the wt protein .pdb file, a list of mutations, a parameter file containing
    the flags for each programm (CONCOORD/GROMACS) and optionally user specific
    .mdp files and tables for GROMACS.
    """
    def __init__(self, wt, mutlist, flags, calculate='stability',
        min_mdp="/Users/linkai/CC_PBSA/min.mdp",
        energy_mdp="/Users/linkai/CC_PBSA/energy.mdp",
        mdrun_table="/Users/linkai/CC_PBSA/table4r-6-12.xvg"
        ):
        """Creates and moves to the main folder upon initialization and copies
        the wt .pdb file into a subdirectory of the working directory.
        self.maindir will be the directory to which each function call returns
        to after completing.
        """
        self.mode = calculate
        self.wt = wt
        self.flags = self.parse_flags(flags)
        self.mut_df = self.parse_mutlist(mutlist)
        self.e_mdp = energy_mdp
        self.min_mdp = min_mdp
        self.mdrun_table = mdrun_table

#        Initialize working directory.
        makedir(self.__repr__())
        shutil.copy(self.wt, self.__repr__())
        os.chdir(self.__repr__())
        self.maindir = os.getcwd()
        makedir(self.__repr__())
        self.wt = self + ".pdb"
        shutil.move(self.wt, self.__repr__())
        self.wdlist = [self.maindir+'/'+self.__repr__()]


    def __repr__(self):
        return self.wt.split('/')[-1][:-4]


    def __add__(self, other):
        """Makes it possible to add this object to strings. Not much else makes
        sense at the moment and it makes some of the source syntax more
        readable.
        """
        return self.__repr__() + other


    def __len__(self):
        """Returns the number of structures that would be generated by
        CONCOORD.
        """
        return int(self.flags['CC']['DISCO FLAGS'] \
            [self.flags['CC']['DISCO FLAGS'].index('-n')+1])


    def parse_flags(self, flags_raw):
        """Parse the list of flags in the .txt flag file for the programs.
        Called upon initialization. Returns a
        dictionary in the following format:

        parsed_flags = {
            'CC': {
                'DIST FLAGS': [list of flags],
                'DISCO FLAGS': [list of flags]
            },
            'gmx': {
                'PDB2GMX FLAGS': [list of flags],
                'EDITCONF FLAGS': [list of flags],
                'GROMPP FLAGS': [list of flags],
                'MDRUN FLAGS': [list of flags],
            }
        }
        
        The list can then be extended directly to other input lists for
        subprocess.run().
        """
        parsed_flags = {
            'CC': {
                'DIST FLAGS': [],
                'DISCO FLAGS': []
            },
            'gmx': {
                'PDB2GMX FLAGS': [],
                'EDITCONF FLAGS': [],
                'GROMPP FLAGS': [],
                'MDRUN FLAGS': [],
            }
        }

#        Search for this file just in case it is not in the current directory of
#        the class.
        flag_file = list(open(flags_raw, 'r'))
        content = [line[:line.index('\n')] for line in flag_file]
        uncommented = []

        for line in content:
            if ';' in line:
                line = line[:line.index(';')]

            if len(line) > 0:
                uncommented.append(' '.join(line.split()))

    #    Indexes the file for where the flags are defined
        idx = [uncommented.index(j) for i in parsed_flags.values() for j in i]
        idx.append(len(uncommented))

        i = 0
        for keys, vals in parsed_flags.items():

            for prog in vals:
                parsed_flags[keys][prog] = unpack([i.split('=') for i in \
                    uncommented[idx[i]+1:idx[i+1]]])
                i += 1
    
        return parsed_flags


    def parse_mutlist(self, mutlist_raw):
        """Parse the list of mutations so that .mutate() can perform mutations
        using PyMOL correctly. Called upon initialization.
        The format of the mutation instruction should be (in one letter code
        and without spaces):
            (*Chain_*) *OriginalAA* *ResidueNumber* *NewAA*
        for exapmle:
            - A20G (for a monomer)
            - B_H10I (for a dimer with a chain named \"B\")
        """
#        One letter AA code to three letter code as presented on PyMOL Wiki.
        aa1 = list("ACDEFGHIKLMNPQRSTVWY")
        aa3 = "ALA CYS ASP GLU PHE GLY HIS ILE LYS LEU \
            MET ASN PRO GLN ARG SER THR VAL TRP TYR".split()
        aa123 = dict(zip(aa1,aa3))

        mut_lst = list(open(mutlist_raw, 'r'))
        mut_lst = [mut.split('\n')[0] for mut in mut_lst]

#        Returned object is a pandas dataframe.
        parsed_mut = pd.DataFrame(
            columns=["Chain", "AA", "Residue", "Mutation"], index=mut_lst)

        parsed_mut['Chain'] = [i[0] if '_' in i else '' for i in mut_lst.copy()]
        parsed_mut['AA'] = [i[0] if '_' not in i else i[i.index('_')+1] \
            for i in mut_lst.copy()]
        parsed_mut['Residue'] = [int_in_str(i) for i in mut_lst]
        parsed_mut['Mutation'] = [aa123[i[-1]] for i in mut_lst]

        return parsed_mut


    def mutate(self):
        """Uses PyMOL and the list of mutations to mutate the wildtype protein.
        Does not accuratly mutate if input structure or mutation instructions
        are flawed. WARNING: No specific message is given if that happens. Best
        to check if the residues in the .pdb file are correctly numbered.
        Updates working directories list (wdlist).
        """
        for m in range(len(self.mut_df)):
            cmd.load(self+'/'+self.wt)
            cmd.wizard('mutagenesis')
            mut_key = self.mut_df.axes[0][m]
#            name = "%s_%s" % (self, mut_key)
            cmd.get_wizard().do_select('///%s/%s' %
                (self.mut_df["Chain"][m], str(self.mut_df["Residue"][m])))
            cmd.get_wizard().set_mode(self.mut_df["Mutation"][m])
            cmd.get_wizard().apply()
            cmd.save(mut_key + ".pdb")
            cmd.reinitialize()
            makedir(mut_key)
            shutil.move(mut_key + ".pdb", mut_key)
            self.wdlist.append(self.maindir+'/'+mut_key)

    
    def concoord(self):
        """Performs the CONCOORD procedure to generate protein structure
        ensembles. Takes additional flags from "flag_parse" as input (pass it
        as "flag_parse_output['CC']"). Make sure that \"CONCOORDRC.bash\" is
        sourced.
        """
        for s in self.structures:
            os.chdir(s[:-4])
            dist_input = [
                'dist',
                '-p', '%s' % s,
                '-op', '%s_dist.pdb' % s[:-4],
                '-og', '%s_dist.gro' % s[:-4],
                '-od', '%s_dist.dat' % s[:-4],
            ]
    
            disco_input = [
                'disco',
                '-d', '%s_dist.dat' % s[:-4],
                '-p', '%s_dist.pdb' % s[:-4],
                '-op', '',
                '-or', '%s_disco.rms' % s[:-4],
                '-of', '%s_disco_Bfac.pdb' % s[:-4]
            ]
            dist_input.extend(self.parsed_flags['CC']['DIST FLAGS'])
            disco_input.extend(self.parsed_flags['CC']['DISCO FLAGS'])
            subprocess.run(dist_input, input=b'1\n1')
            subprocess.run(disco_input)
            
            for n in range(1, self.n_structs+1):
                nr = str(n)
                makedir(nr)
                shutil.move(nr+'.pdb', nr)
                self.subdir.append(os.getcwd() + '/' + nr)

            os.chdir('..')

        self.wdlist = [d+'/'+str(nr) \
            for d in self.wdlist for nr in range(1, len(self)+1)]


    def minimize(self):
        """Minimzes all .pdb files in self.wdlist.
        """
        pass


    def electrostatics(self):
        pass


    def lj(self):
        """calculates the single point Lennard Jones Energy (1-4 and
        shortrange) of all self.structures
        """
        pass


    def area(self):
        """Calculate the solvent accessible surface area and saves it to
        area.xvg. If the mode is set to affinity, only the wt protein structure
        ensemble will be used and the values for the interaction surface will
        be written into the .xvg file
        """
        pass


    def schlitter(self):
        """Calculates an upper limit of the entropy according to Schlitter's
        formula. Used in .fullrun() if the mode is stability
        """
        pass


    def fullrun(self):
        """Performs a full run based on the list of mutations, number of
        CONCOORD structures and other parameters. Methods used will depend on
        the mode chosen (stability/affinity).
        """
        pass


if __name__ == '__main__':
    x = DataGenerator("1pga.pdb", "mut.txt", "param.txt")
    x.mutate()
    x.concoord()
#    for i in x.wdlist:
#        print(i[len(x.maindir):])
